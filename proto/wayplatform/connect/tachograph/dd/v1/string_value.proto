edition = "2023";

package wayplatform.connect.tachograph.dd.v1;

import "buf/validate/validate.proto";
import "wayplatform/connect/tachograph/dd/v1/encoding.proto";

// StringValue provides a canonical representation for code-paged string types
// found in the tachograph regulations.
//
// Many ASN.1 types in the specification, such as `Name` (DD 2.99) and
// `Address` (DD 2.2), are defined as a `SEQUENCE` containing a numeric
// code page and an octet string.
//
// This message solves the problem of representing these types faithfully
// by storing both the original raw bytes and the corresponding encoding
// information. This ensures that data can be unmarshalled for use and
// then marshalled back to its exact original binary format without data loss.
message StringValue {
  // The character encoding as determined by the code page byte.
  Encoding encoding = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum = {
      defined_only: true
      not_in: [0]
    }
  ];

  // The serialized length of the string data.
  //
  // If both 'raw_data' and 'length' are present, their lengths must agree.
  int32 length = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).int32.gt = 0
  ];

  // A user-friendly, UTF-8 representation of the string, generated by
  // decoding and trimming the 'raw_data' bytes.
  //
  // When raw_data is not present, this field will be used during marshalling
  // and padded with spaces to the length.
  string value = 3 [(buf.validate.field).required = true];

  // The raw, original byte representation of the string as it appears in
  // the binary format, including the code page byte.
  bytes raw_data = 4 [(buf.validate.field).bytes.min_len = 2];

  option (buf.validate.message).cel = {
    id: "length.raw_data.equal"
    message: "if raw_data is present, length must match the size of the raw data (without the code page)"
    expression:
      "!has(this.raw_data) ? true"
      " : this.length == this.raw_data.size() - 1"
  };
}
