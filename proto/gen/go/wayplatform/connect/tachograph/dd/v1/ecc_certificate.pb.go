// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: wayplatform/connect/tachograph/dd/v1/ecc_certificate.proto

package ddv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// EccCertificate represents an ECC-based certificate used in second-generation
// tachograph cards.
//
// This certificate type is defined in Appendix 11, Section 9.3.2 (PART B -
// SECOND-GENERATION TACHOGRAPH SYSTEM), Table 4 of the EU regulation.
//
// The certificate uses an ASN.1 TLV structure and ranges from 204 to 341 bytes
// in length depending on the elliptic curve used.
//
// ASN.1 Structure:
//
//	ECC Certificate (Tag '7F 21'):
//	  ECC Certificate Body (Tag '7F 4E'):
//	    - Certificate Profile Identifier (Tag '5F 29'): 1 byte
//	    - Certificate Authority Reference (Tag '42'): 8 bytes
//	    - Certificate Holder Authorisation (Tag '5F 4C'): 7 bytes
//	    - Public Key (Tag '7F 49'):
//	      - Domain Parameters (Tag '06'): OID
//	      - Public Point (Tag '86'): variable length
//	    - Certificate Holder Reference (Tag '5F 20'): 8 bytes
//	    - Certificate Effective Date (Tag '5F 25'): 4 bytes (TimeReal)
//	    - Certificate Expiration Date (Tag '5F 24'): 4 bytes (TimeReal)
//	  ECC Certificate Signature (Tag '5F 37'): variable length (R || S)
type EccCertificate struct {
	state                                     protoimpl.MessageState       `protogen:"opaque.v1"`
	xxx_hidden_CertificateProfileIdentifier   int32                        `protobuf:"varint,1,opt,name=certificate_profile_identifier,json=certificateProfileIdentifier"`
	xxx_hidden_CertificateAuthorityReference  uint64                       `protobuf:"varint,2,opt,name=certificate_authority_reference,json=certificateAuthorityReference"`
	xxx_hidden_CertificateHolderAuthorisation []byte                       `protobuf:"bytes,3,opt,name=certificate_holder_authorisation,json=certificateHolderAuthorisation"`
	xxx_hidden_PublicKey                      *EccCertificate_PublicKey    `protobuf:"bytes,4,opt,name=public_key,json=publicKey"`
	xxx_hidden_CertificateHolderReference     uint64                       `protobuf:"varint,5,opt,name=certificate_holder_reference,json=certificateHolderReference"`
	xxx_hidden_CertificateEffectiveDate       *timestamppb.Timestamp       `protobuf:"bytes,6,opt,name=certificate_effective_date,json=certificateEffectiveDate"`
	xxx_hidden_CertificateExpirationDate      *timestamppb.Timestamp       `protobuf:"bytes,7,opt,name=certificate_expiration_date,json=certificateExpirationDate"`
	xxx_hidden_Signature                      *EccCertificate_EccSignature `protobuf:"bytes,8,opt,name=signature"`
	xxx_hidden_SignatureValid                 bool                         `protobuf:"varint,9,opt,name=signature_valid,json=signatureValid"`
	xxx_hidden_RawData                        []byte                       `protobuf:"bytes,10,opt,name=raw_data,json=rawData"`
	XXX_raceDetectHookData                    protoimpl.RaceDetectHookData
	XXX_presence                              [1]uint32
	unknownFields                             protoimpl.UnknownFields
	sizeCache                                 protoimpl.SizeCache
}

func (x *EccCertificate) Reset() {
	*x = EccCertificate{}
	mi := &file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EccCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EccCertificate) ProtoMessage() {}

func (x *EccCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *EccCertificate) GetCertificateProfileIdentifier() int32 {
	if x != nil {
		return x.xxx_hidden_CertificateProfileIdentifier
	}
	return 0
}

func (x *EccCertificate) GetCertificateAuthorityReference() uint64 {
	if x != nil {
		return x.xxx_hidden_CertificateAuthorityReference
	}
	return 0
}

func (x *EccCertificate) GetCertificateHolderAuthorisation() []byte {
	if x != nil {
		return x.xxx_hidden_CertificateHolderAuthorisation
	}
	return nil
}

func (x *EccCertificate) GetPublicKey() *EccCertificate_PublicKey {
	if x != nil {
		return x.xxx_hidden_PublicKey
	}
	return nil
}

func (x *EccCertificate) GetCertificateHolderReference() uint64 {
	if x != nil {
		return x.xxx_hidden_CertificateHolderReference
	}
	return 0
}

func (x *EccCertificate) GetCertificateEffectiveDate() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_CertificateEffectiveDate
	}
	return nil
}

func (x *EccCertificate) GetCertificateExpirationDate() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_CertificateExpirationDate
	}
	return nil
}

func (x *EccCertificate) GetSignature() *EccCertificate_EccSignature {
	if x != nil {
		return x.xxx_hidden_Signature
	}
	return nil
}

func (x *EccCertificate) GetSignatureValid() bool {
	if x != nil {
		return x.xxx_hidden_SignatureValid
	}
	return false
}

func (x *EccCertificate) GetRawData() []byte {
	if x != nil {
		return x.xxx_hidden_RawData
	}
	return nil
}

func (x *EccCertificate) SetCertificateProfileIdentifier(v int32) {
	x.xxx_hidden_CertificateProfileIdentifier = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 10)
}

func (x *EccCertificate) SetCertificateAuthorityReference(v uint64) {
	x.xxx_hidden_CertificateAuthorityReference = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 10)
}

func (x *EccCertificate) SetCertificateHolderAuthorisation(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_CertificateHolderAuthorisation = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 10)
}

func (x *EccCertificate) SetPublicKey(v *EccCertificate_PublicKey) {
	x.xxx_hidden_PublicKey = v
}

func (x *EccCertificate) SetCertificateHolderReference(v uint64) {
	x.xxx_hidden_CertificateHolderReference = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 10)
}

func (x *EccCertificate) SetCertificateEffectiveDate(v *timestamppb.Timestamp) {
	x.xxx_hidden_CertificateEffectiveDate = v
}

func (x *EccCertificate) SetCertificateExpirationDate(v *timestamppb.Timestamp) {
	x.xxx_hidden_CertificateExpirationDate = v
}

func (x *EccCertificate) SetSignature(v *EccCertificate_EccSignature) {
	x.xxx_hidden_Signature = v
}

func (x *EccCertificate) SetSignatureValid(v bool) {
	x.xxx_hidden_SignatureValid = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 8, 10)
}

func (x *EccCertificate) SetRawData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_RawData = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 9, 10)
}

func (x *EccCertificate) HasCertificateProfileIdentifier() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *EccCertificate) HasCertificateAuthorityReference() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *EccCertificate) HasCertificateHolderAuthorisation() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *EccCertificate) HasPublicKey() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_PublicKey != nil
}

func (x *EccCertificate) HasCertificateHolderReference() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *EccCertificate) HasCertificateEffectiveDate() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_CertificateEffectiveDate != nil
}

func (x *EccCertificate) HasCertificateExpirationDate() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_CertificateExpirationDate != nil
}

func (x *EccCertificate) HasSignature() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_Signature != nil
}

func (x *EccCertificate) HasSignatureValid() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 8)
}

func (x *EccCertificate) HasRawData() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 9)
}

func (x *EccCertificate) ClearCertificateProfileIdentifier() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_CertificateProfileIdentifier = 0
}

func (x *EccCertificate) ClearCertificateAuthorityReference() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_CertificateAuthorityReference = 0
}

func (x *EccCertificate) ClearCertificateHolderAuthorisation() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_CertificateHolderAuthorisation = nil
}

func (x *EccCertificate) ClearPublicKey() {
	x.xxx_hidden_PublicKey = nil
}

func (x *EccCertificate) ClearCertificateHolderReference() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_CertificateHolderReference = 0
}

func (x *EccCertificate) ClearCertificateEffectiveDate() {
	x.xxx_hidden_CertificateEffectiveDate = nil
}

func (x *EccCertificate) ClearCertificateExpirationDate() {
	x.xxx_hidden_CertificateExpirationDate = nil
}

func (x *EccCertificate) ClearSignature() {
	x.xxx_hidden_Signature = nil
}

func (x *EccCertificate) ClearSignatureValid() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 8)
	x.xxx_hidden_SignatureValid = false
}

func (x *EccCertificate) ClearRawData() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 9)
	x.xxx_hidden_RawData = nil
}

type EccCertificate_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Certificate Profile Identifier (CPI) - identifies the certificate profile
	// version. Version 1 (as specified in Table 4) uses value '00'.
	CertificateProfileIdentifier *int32
	// Certificate Authority Reference (CAR) - identifies the public key to be
	// used to verify the certificate signature. Equal to the Certificate Holder
	// Reference in the certificate of the corresponding certificate authority.
	CertificateAuthorityReference *uint64
	// Certificate Holder Authorisation (CHA) - identifies the type of certificate.
	// Consists of the six most significant bytes of the Tachograph Application ID,
	// concatenated with the equipment type.
	// - Gen2: FF 53 4D 52 44 54 (FF SMRDT) + equipment type byte
	CertificateHolderAuthorisation []byte
	// Public key for this certificate.
	PublicKey *EccCertificate_PublicKey
	// Certificate Holder Reference (CHR) - uniquely identifies the certificate
	// holder and serves as a Subject Key Identifier to reference the public key.
	CertificateHolderReference *uint64
	// Certificate Effective Date - the date from which the certificate is valid.
	CertificateEffectiveDate *timestamppb.Timestamp
	// Certificate Expiration Date - the date after which the certificate is
	// no longer valid.
	CertificateExpirationDate *timestamppb.Timestamp
	// Digital signature over the certificate body.
	// The signature is computed over the full ASN.1 encoding of the certificate
	// body (including tag and length).
	Signature *EccCertificate_EccSignature
	// Indicates whether the signature was successfully verified during parsing.
	// This field is only populated if the Certificate Authority's public key
	// was available at parse time.
	SignatureValid *bool
	// Raw certificate data as stored in the file - variable length (204-341 bytes).
	// This includes the complete ASN.1 TLV structure.
	RawData []byte
}

func (b0 EccCertificate_builder) Build() *EccCertificate {
	m0 := &EccCertificate{}
	b, x := &b0, m0
	_, _ = b, x
	if b.CertificateProfileIdentifier != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 10)
		x.xxx_hidden_CertificateProfileIdentifier = *b.CertificateProfileIdentifier
	}
	if b.CertificateAuthorityReference != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 10)
		x.xxx_hidden_CertificateAuthorityReference = *b.CertificateAuthorityReference
	}
	if b.CertificateHolderAuthorisation != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 10)
		x.xxx_hidden_CertificateHolderAuthorisation = b.CertificateHolderAuthorisation
	}
	x.xxx_hidden_PublicKey = b.PublicKey
	if b.CertificateHolderReference != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 10)
		x.xxx_hidden_CertificateHolderReference = *b.CertificateHolderReference
	}
	x.xxx_hidden_CertificateEffectiveDate = b.CertificateEffectiveDate
	x.xxx_hidden_CertificateExpirationDate = b.CertificateExpirationDate
	x.xxx_hidden_Signature = b.Signature
	if b.SignatureValid != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 8, 10)
		x.xxx_hidden_SignatureValid = *b.SignatureValid
	}
	if b.RawData != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 9, 10)
		x.xxx_hidden_RawData = b.RawData
	}
	return m0
}

// PublicKey contains the ECC public key information.
type EccCertificate_PublicKey struct {
	state                          protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_DomainParametersOid *string                `protobuf:"bytes,1,opt,name=domain_parameters_oid,json=domainParametersOid"`
	xxx_hidden_PublicPointX        []byte                 `protobuf:"bytes,2,opt,name=public_point_x,json=publicPointX"`
	xxx_hidden_PublicPointY        []byte                 `protobuf:"bytes,3,opt,name=public_point_y,json=publicPointY"`
	XXX_raceDetectHookData         protoimpl.RaceDetectHookData
	XXX_presence                   [1]uint32
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *EccCertificate_PublicKey) Reset() {
	*x = EccCertificate_PublicKey{}
	mi := &file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EccCertificate_PublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EccCertificate_PublicKey) ProtoMessage() {}

func (x *EccCertificate_PublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *EccCertificate_PublicKey) GetDomainParametersOid() string {
	if x != nil {
		if x.xxx_hidden_DomainParametersOid != nil {
			return *x.xxx_hidden_DomainParametersOid
		}
		return ""
	}
	return ""
}

func (x *EccCertificate_PublicKey) GetPublicPointX() []byte {
	if x != nil {
		return x.xxx_hidden_PublicPointX
	}
	return nil
}

func (x *EccCertificate_PublicKey) GetPublicPointY() []byte {
	if x != nil {
		return x.xxx_hidden_PublicPointY
	}
	return nil
}

func (x *EccCertificate_PublicKey) SetDomainParametersOid(v string) {
	x.xxx_hidden_DomainParametersOid = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 3)
}

func (x *EccCertificate_PublicKey) SetPublicPointX(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_PublicPointX = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 3)
}

func (x *EccCertificate_PublicKey) SetPublicPointY(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_PublicPointY = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 2, 3)
}

func (x *EccCertificate_PublicKey) HasDomainParametersOid() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *EccCertificate_PublicKey) HasPublicPointX() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *EccCertificate_PublicKey) HasPublicPointY() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 2)
}

func (x *EccCertificate_PublicKey) ClearDomainParametersOid() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_DomainParametersOid = nil
}

func (x *EccCertificate_PublicKey) ClearPublicPointX() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_PublicPointX = nil
}

func (x *EccCertificate_PublicKey) ClearPublicPointY() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 2)
	x.xxx_hidden_PublicPointY = nil
}

type EccCertificate_PublicKey_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Domain parameters as an ASN.1 Object Identifier referencing a set of
	// standardized domain parameters (elliptic curve).
	// Common values (see Table 1 in Section 8.2.2):
	//   - brainpoolP256r1: 1.3.36.3.3.2.8.1.1.7
	//   - brainpoolP384r1: 1.3.36.3.3.2.8.1.1.11
	//   - brainpoolP512r1: 1.3.36.3.3.2.8.1.1.13
	//   - nistP256:        1.2.840.10045.3.1.7
	//   - nistP384:        1.3.132.0.34
	//   - nistP521:        1.3.132.0.35
	DomainParametersOid *string
	// Public point X coordinate (uncompressed encoding).
	PublicPointX []byte
	// Public point Y coordinate (uncompressed encoding).
	PublicPointY []byte
}

func (b0 EccCertificate_PublicKey_builder) Build() *EccCertificate_PublicKey {
	m0 := &EccCertificate_PublicKey{}
	b, x := &b0, m0
	_, _ = b, x
	if b.DomainParametersOid != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 3)
		x.xxx_hidden_DomainParametersOid = b.DomainParametersOid
	}
	if b.PublicPointX != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 3)
		x.xxx_hidden_PublicPointX = b.PublicPointX
	}
	if b.PublicPointY != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 2, 3)
		x.xxx_hidden_PublicPointY = b.PublicPointY
	}
	return m0
}

// EccSignature contains the ECDSA signature over the certificate body.
type EccCertificate_EccSignature struct {
	state                  protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_R           []byte                 `protobuf:"bytes,1,opt,name=r"`
	xxx_hidden_S           []byte                 `protobuf:"bytes,2,opt,name=s"`
	XXX_raceDetectHookData protoimpl.RaceDetectHookData
	XXX_presence           [1]uint32
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *EccCertificate_EccSignature) Reset() {
	*x = EccCertificate_EccSignature{}
	mi := &file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EccCertificate_EccSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EccCertificate_EccSignature) ProtoMessage() {}

func (x *EccCertificate_EccSignature) ProtoReflect() protoreflect.Message {
	mi := &file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *EccCertificate_EccSignature) GetR() []byte {
	if x != nil {
		return x.xxx_hidden_R
	}
	return nil
}

func (x *EccCertificate_EccSignature) GetS() []byte {
	if x != nil {
		return x.xxx_hidden_S
	}
	return nil
}

func (x *EccCertificate_EccSignature) SetR(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_R = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 2)
}

func (x *EccCertificate_EccSignature) SetS(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_S = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 2)
}

func (x *EccCertificate_EccSignature) HasR() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *EccCertificate_EccSignature) HasS() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *EccCertificate_EccSignature) ClearR() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_R = nil
}

func (x *EccCertificate_EccSignature) ClearS() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_S = nil
}

type EccCertificate_EccSignature_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// R component of the ECDSA signature.
	// Length depends on the curve: 32, 48, or 64-66 bytes.
	R []byte
	// S component of the ECDSA signature.
	// Length depends on the curve: 32, 48, or 64-66 bytes.
	S []byte
}

func (b0 EccCertificate_EccSignature_builder) Build() *EccCertificate_EccSignature {
	m0 := &EccCertificate_EccSignature{}
	b, x := &b0, m0
	_, _ = b, x
	if b.R != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 2)
		x.xxx_hidden_R = b.R
	}
	if b.S != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 2)
		x.xxx_hidden_S = b.S
	}
	return m0
}

var File_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto protoreflect.FileDescriptor

const file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_rawDesc = "" +
	"\n" +
	":wayplatform/connect/tachograph/dd/v1/ecc_certificate.proto\x12$wayplatform.connect.tachograph.dd.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\x9e\a\n" +
	"\x0eEccCertificate\x12D\n" +
	"\x1ecertificate_profile_identifier\x18\x01 \x01(\x05R\x1ccertificateProfileIdentifier\x12F\n" +
	"\x1fcertificate_authority_reference\x18\x02 \x01(\x04R\x1dcertificateAuthorityReference\x12H\n" +
	" certificate_holder_authorisation\x18\x03 \x01(\fR\x1ecertificateHolderAuthorisation\x12]\n" +
	"\n" +
	"public_key\x18\x04 \x01(\v2>.wayplatform.connect.tachograph.dd.v1.EccCertificate.PublicKeyR\tpublicKey\x12@\n" +
	"\x1ccertificate_holder_reference\x18\x05 \x01(\x04R\x1acertificateHolderReference\x12X\n" +
	"\x1acertificate_effective_date\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x18certificateEffectiveDate\x12Z\n" +
	"\x1bcertificate_expiration_date\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\x19certificateExpirationDate\x12_\n" +
	"\tsignature\x18\b \x01(\v2A.wayplatform.connect.tachograph.dd.v1.EccCertificate.EccSignatureR\tsignature\x12'\n" +
	"\x0fsignature_valid\x18\t \x01(\bR\x0esignatureValid\x12\x19\n" +
	"\braw_data\x18\n" +
	" \x01(\fR\arawData\x1a\x8b\x01\n" +
	"\tPublicKey\x122\n" +
	"\x15domain_parameters_oid\x18\x01 \x01(\tR\x13domainParametersOid\x12$\n" +
	"\x0epublic_point_x\x18\x02 \x01(\fR\fpublicPointX\x12$\n" +
	"\x0epublic_point_y\x18\x03 \x01(\fR\fpublicPointY\x1a*\n" +
	"\fEccSignature\x12\f\n" +
	"\x01r\x18\x01 \x01(\fR\x01r\x12\f\n" +
	"\x01s\x18\x02 \x01(\fR\x01sB\xd2\x02\n" +
	"(com.wayplatform.connect.tachograph.dd.v1B\x13EccCertificateProtoP\x01Z\\github.com/way-platform/tachograph-go/proto/gen/go/wayplatform/connect/tachograph/dd/v1;ddv1\xa2\x02\x04WCTD\xaa\x02$Wayplatform.Connect.Tachograph.Dd.V1\xca\x02$Wayplatform\\Connect\\Tachograph\\Dd\\V1\xe2\x020Wayplatform\\Connect\\Tachograph\\Dd\\V1\\GPBMetadata\xea\x02(Wayplatform::Connect::Tachograph::Dd::V1b\beditionsp\xe8\a"

var file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_goTypes = []any{
	(*EccCertificate)(nil),              // 0: wayplatform.connect.tachograph.dd.v1.EccCertificate
	(*EccCertificate_PublicKey)(nil),    // 1: wayplatform.connect.tachograph.dd.v1.EccCertificate.PublicKey
	(*EccCertificate_EccSignature)(nil), // 2: wayplatform.connect.tachograph.dd.v1.EccCertificate.EccSignature
	(*timestamppb.Timestamp)(nil),       // 3: google.protobuf.Timestamp
}
var file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_depIdxs = []int32{
	1, // 0: wayplatform.connect.tachograph.dd.v1.EccCertificate.public_key:type_name -> wayplatform.connect.tachograph.dd.v1.EccCertificate.PublicKey
	3, // 1: wayplatform.connect.tachograph.dd.v1.EccCertificate.certificate_effective_date:type_name -> google.protobuf.Timestamp
	3, // 2: wayplatform.connect.tachograph.dd.v1.EccCertificate.certificate_expiration_date:type_name -> google.protobuf.Timestamp
	2, // 3: wayplatform.connect.tachograph.dd.v1.EccCertificate.signature:type_name -> wayplatform.connect.tachograph.dd.v1.EccCertificate.EccSignature
	4, // [4:4] is the sub-list for method output_type
	4, // [4:4] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_init() }
func file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_init() {
	if File_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_rawDesc), len(file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_goTypes,
		DependencyIndexes: file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_depIdxs,
		MessageInfos:      file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_msgTypes,
	}.Build()
	File_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto = out.File
	file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_goTypes = nil
	file_wayplatform_connect_tachograph_dd_v1_ecc_certificate_proto_depIdxs = nil
}
