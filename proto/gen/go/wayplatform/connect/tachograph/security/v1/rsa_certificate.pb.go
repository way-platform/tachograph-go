// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: wayplatform/connect/tachograph/security/v1/rsa_certificate.proto

package securityv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// RsaCertificate represents an RSA-based certificate used in first-generation
// tachograph systems.
//
// This certificate type implements the digital signature scheme specified in
// Appendix 11, Section 3.3 (PART A - FIRST-GENERATION TACHOGRAPH SYSTEM).
//
// The certificate uses ISO/IEC 9796-2 digital signature with partial message
// recovery. This scheme embeds part of the certificate content within the
// signature itself, allowing verification and content extraction in a single
// operation.
//
// See Appendix 11, Section 3.3 for the complete specification.
//
// Binary Structure (194 bytes):
//
//	Bytes 0-127:   Sr  - Digital signature with partial message recovery
//	Bytes 128-185: Cn' - Non-recoverable certificate content (58 bytes)
//	Bytes 186-193: CAR'- Certificate Authority Reference (8 bytes)
//
// The signature Sr embeds the recoverable part of the certificate:
//
//	Byte 0:        Header (0x6A)
//	Bytes 1-106:   Cr' - Recoverable certificate content
//	Bytes 107-126: H'  - SHA-1 hash of complete content (Cr' || Cn')
//	Byte 127:      Trailer (0xBC)
//
// Complete Certificate Content C' = Cr' || Cn' (164 bytes):
//
//	Byte 0:        CPI - Certificate Profile Identifier (0x01)
//	Bytes 1-8:     CAR - Certificate Authority Reference
//	Bytes 9-15:    CHA - Certificate Holder Authorisation
//	Bytes 16-19:   EOV - End of Validity (TimeReal, or 0xFFFFFFFF)
//	Bytes 20-27:   CHR - Certificate Holder Reference
//	Bytes 28-155:  n   - RSA modulus (128 bytes)
//	Bytes 156-163: e   - RSA public exponent (8 bytes)
//
// Signature Recovery Process:
//
// 1. Extract CAR' from bytes 186-193 to identify the CA public key
// 2. Apply RSA operation: Sr' = Sr^e mod n (using CA's public key)
// 3. Verify header (0x6A) and trailer (0xBC) in Sr'
// 4. Extract Cr' from Sr'
// 5. Reconstruct C' = Cr' || Cn'
// 6. Extract H' from Sr' and verify SHA-1(C') = H'
// 7. If verification succeeds, extract semantic fields from C'
//
// See Appendix 11, Section 3.3.2 for the detailed recovery algorithm.
type RsaCertificate struct {
	state                                    protoimpl.MessageState `protogen:"opaque.v1"`
	xxx_hidden_CertificateHolderReference    *string                `protobuf:"bytes,1,opt,name=certificate_holder_reference,json=certificateHolderReference"`
	xxx_hidden_CertificateAuthorityReference *string                `protobuf:"bytes,2,opt,name=certificate_authority_reference,json=certificateAuthorityReference"`
	xxx_hidden_EndOfValidity                 *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=end_of_validity,json=endOfValidity"`
	xxx_hidden_RsaModulus                    []byte                 `protobuf:"bytes,4,opt,name=rsa_modulus,json=rsaModulus"`
	xxx_hidden_RsaExponent                   []byte                 `protobuf:"bytes,5,opt,name=rsa_exponent,json=rsaExponent"`
	xxx_hidden_RawData                       []byte                 `protobuf:"bytes,6,opt,name=raw_data,json=rawData"`
	xxx_hidden_SignatureValid                bool                   `protobuf:"varint,7,opt,name=signature_valid,json=signatureValid"`
	XXX_raceDetectHookData                   protoimpl.RaceDetectHookData
	XXX_presence                             [1]uint32
	unknownFields                            protoimpl.UnknownFields
	sizeCache                                protoimpl.SizeCache
}

func (x *RsaCertificate) Reset() {
	*x = RsaCertificate{}
	mi := &file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RsaCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RsaCertificate) ProtoMessage() {}

func (x *RsaCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

func (x *RsaCertificate) GetCertificateHolderReference() string {
	if x != nil {
		if x.xxx_hidden_CertificateHolderReference != nil {
			return *x.xxx_hidden_CertificateHolderReference
		}
		return ""
	}
	return ""
}

func (x *RsaCertificate) GetCertificateAuthorityReference() string {
	if x != nil {
		if x.xxx_hidden_CertificateAuthorityReference != nil {
			return *x.xxx_hidden_CertificateAuthorityReference
		}
		return ""
	}
	return ""
}

func (x *RsaCertificate) GetEndOfValidity() *timestamppb.Timestamp {
	if x != nil {
		return x.xxx_hidden_EndOfValidity
	}
	return nil
}

func (x *RsaCertificate) GetRsaModulus() []byte {
	if x != nil {
		return x.xxx_hidden_RsaModulus
	}
	return nil
}

func (x *RsaCertificate) GetRsaExponent() []byte {
	if x != nil {
		return x.xxx_hidden_RsaExponent
	}
	return nil
}

func (x *RsaCertificate) GetRawData() []byte {
	if x != nil {
		return x.xxx_hidden_RawData
	}
	return nil
}

func (x *RsaCertificate) GetSignatureValid() bool {
	if x != nil {
		return x.xxx_hidden_SignatureValid
	}
	return false
}

func (x *RsaCertificate) SetCertificateHolderReference(v string) {
	x.xxx_hidden_CertificateHolderReference = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 0, 7)
}

func (x *RsaCertificate) SetCertificateAuthorityReference(v string) {
	x.xxx_hidden_CertificateAuthorityReference = &v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 1, 7)
}

func (x *RsaCertificate) SetEndOfValidity(v *timestamppb.Timestamp) {
	x.xxx_hidden_EndOfValidity = v
}

func (x *RsaCertificate) SetRsaModulus(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_RsaModulus = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 3, 7)
}

func (x *RsaCertificate) SetRsaExponent(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_RsaExponent = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 4, 7)
}

func (x *RsaCertificate) SetRawData(v []byte) {
	if v == nil {
		v = []byte{}
	}
	x.xxx_hidden_RawData = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 5, 7)
}

func (x *RsaCertificate) SetSignatureValid(v bool) {
	x.xxx_hidden_SignatureValid = v
	protoimpl.X.SetPresent(&(x.XXX_presence[0]), 6, 7)
}

func (x *RsaCertificate) HasCertificateHolderReference() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 0)
}

func (x *RsaCertificate) HasCertificateAuthorityReference() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 1)
}

func (x *RsaCertificate) HasEndOfValidity() bool {
	if x == nil {
		return false
	}
	return x.xxx_hidden_EndOfValidity != nil
}

func (x *RsaCertificate) HasRsaModulus() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 3)
}

func (x *RsaCertificate) HasRsaExponent() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 4)
}

func (x *RsaCertificate) HasRawData() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 5)
}

func (x *RsaCertificate) HasSignatureValid() bool {
	if x == nil {
		return false
	}
	return protoimpl.X.Present(&(x.XXX_presence[0]), 6)
}

func (x *RsaCertificate) ClearCertificateHolderReference() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 0)
	x.xxx_hidden_CertificateHolderReference = nil
}

func (x *RsaCertificate) ClearCertificateAuthorityReference() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 1)
	x.xxx_hidden_CertificateAuthorityReference = nil
}

func (x *RsaCertificate) ClearEndOfValidity() {
	x.xxx_hidden_EndOfValidity = nil
}

func (x *RsaCertificate) ClearRsaModulus() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 3)
	x.xxx_hidden_RsaModulus = nil
}

func (x *RsaCertificate) ClearRsaExponent() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 4)
	x.xxx_hidden_RsaExponent = nil
}

func (x *RsaCertificate) ClearRawData() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 5)
	x.xxx_hidden_RawData = nil
}

func (x *RsaCertificate) ClearSignatureValid() {
	protoimpl.X.ClearPresent(&(x.XXX_presence[0]), 6)
	x.xxx_hidden_SignatureValid = false
}

type RsaCertificate_builder struct {
	_ [0]func() // Prevents comparability and use of unkeyed literals for the builder.

	// Certificate Holder Reference (CHR) - uniquely identifies the certificate
	// holder and serves as a Subject Key Identifier.
	//
	// Extracted from bytes 20-27 of the recovered certificate content during
	// signature recovery. Stored as a decimal string representation of the
	// 64-bit value (e.g., "234554709598273281").
	CertificateHolderReference *string
	// Certificate Authority Reference (CAR) - identifies the certification
	// authority that issued and signed this certificate.
	//
	// This value appears twice in the certificate structure:
	// - At bytes 1-8 of the recovered content (signed)
	// - At bytes 186-193 of the certificate (cleartext, as CAR')
	//
	// The cleartext CAR' allows identification of the CA public key needed for
	// signature recovery without requiring prior knowledge. Stored as a decimal
	// string representation of the 64-bit value.
	CertificateAuthorityReference *string
	// End of Validity timestamp for this certificate.
	//
	// Extracted from bytes 16-19 of the recovered certificate content. This
	// timestamp indicates when the certificate expires. A value of 0xFFFFFFFF
	// (2106-02-07 06:28:15 UTC) indicates no expiry date.
	EndOfValidity *timestamppb.Timestamp
	// RSA public key modulus (n) - 128 bytes.
	//
	// Extracted from bytes 28-155 of the recovered certificate content during
	// signature recovery. This is the modulus component of the RSA public key
	// pair being certified, encoded as a 128-byte (1024-bit) big-endian integer.
	RsaModulus []byte
	// RSA public key exponent (e) - 8 bytes.
	//
	// Extracted from bytes 156-163 of the recovered certificate content during
	// signature recovery. This is the exponent component of the RSA public key
	// pair being certified, encoded as an 8-byte (64-bit) big-endian integer.
	RsaExponent []byte
	// Raw certificate data as stored in the file - always 194 bytes.
	//
	// This includes the complete binary representation: the signature Sr (128 bytes),
	// the non-recoverable content Cn' (58 bytes), and the cleartext CAR' (8 bytes).
	//
	// Preserving the raw data ensures perfect round-trip fidelity and allows
	// re-verification of the signature.
	RawData []byte
	// Indicates whether the certificate's signature has been successfully verified.
	//
	// When true, the signature recovery process (as specified in Appendix 11,
	// Section 3.3.2) has completed successfully:
	// - The header and trailer bytes were correct (0x6A and 0xBC)
	// - The recovered hash H' matched SHA-1(Cr' || Cn')
	// - The semantic fields (CHR, EOV, modulus, exponent) were extracted
	//
	// When false or unset, either verification has not been performed or the
	// signature is invalid.
	SignatureValid *bool
}

func (b0 RsaCertificate_builder) Build() *RsaCertificate {
	m0 := &RsaCertificate{}
	b, x := &b0, m0
	_, _ = b, x
	if b.CertificateHolderReference != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 0, 7)
		x.xxx_hidden_CertificateHolderReference = b.CertificateHolderReference
	}
	if b.CertificateAuthorityReference != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 1, 7)
		x.xxx_hidden_CertificateAuthorityReference = b.CertificateAuthorityReference
	}
	x.xxx_hidden_EndOfValidity = b.EndOfValidity
	if b.RsaModulus != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 3, 7)
		x.xxx_hidden_RsaModulus = b.RsaModulus
	}
	if b.RsaExponent != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 4, 7)
		x.xxx_hidden_RsaExponent = b.RsaExponent
	}
	if b.RawData != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 5, 7)
		x.xxx_hidden_RawData = b.RawData
	}
	if b.SignatureValid != nil {
		protoimpl.X.SetPresentNonAtomic(&(x.XXX_presence[0]), 6, 7)
		x.xxx_hidden_SignatureValid = *b.SignatureValid
	}
	return m0
}

var File_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto protoreflect.FileDescriptor

const file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_rawDesc = "" +
	"\n" +
	"@wayplatform/connect/tachograph/security/v1/rsa_certificate.proto\x12*wayplatform.connect.tachograph.security.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xe6\x02\n" +
	"\x0eRsaCertificate\x12@\n" +
	"\x1ccertificate_holder_reference\x18\x01 \x01(\tR\x1acertificateHolderReference\x12F\n" +
	"\x1fcertificate_authority_reference\x18\x02 \x01(\tR\x1dcertificateAuthorityReference\x12B\n" +
	"\x0fend_of_validity\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\rendOfValidity\x12\x1f\n" +
	"\vrsa_modulus\x18\x04 \x01(\fR\n" +
	"rsaModulus\x12!\n" +
	"\frsa_exponent\x18\x05 \x01(\fR\vrsaExponent\x12\x19\n" +
	"\braw_data\x18\x06 \x01(\fR\arawData\x12'\n" +
	"\x0fsignature_valid\x18\a \x01(\bR\x0esignatureValidB\xfc\x02\n" +
	".com.wayplatform.connect.tachograph.security.v1B\x13RsaCertificateProtoP\x01Zhgithub.com/way-platform/tachograph-go/proto/gen/go/wayplatform/connect/tachograph/security/v1;securityv1\xa2\x02\x04WCTS\xaa\x02*Wayplatform.Connect.Tachograph.Security.V1\xca\x02*Wayplatform\\Connect\\Tachograph\\Security\\V1\xe2\x026Wayplatform\\Connect\\Tachograph\\Security\\V1\\GPBMetadata\xea\x02.Wayplatform::Connect::Tachograph::Security::V1b\beditionsp\xe8\a"

var file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_goTypes = []any{
	(*RsaCertificate)(nil),        // 0: wayplatform.connect.tachograph.security.v1.RsaCertificate
	(*timestamppb.Timestamp)(nil), // 1: google.protobuf.Timestamp
}
var file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_depIdxs = []int32{
	1, // 0: wayplatform.connect.tachograph.security.v1.RsaCertificate.end_of_validity:type_name -> google.protobuf.Timestamp
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_init() }
func file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_init() {
	if File_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_rawDesc), len(file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_goTypes,
		DependencyIndexes: file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_depIdxs,
		MessageInfos:      file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_msgTypes,
	}.Build()
	File_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto = out.File
	file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_goTypes = nil
	file_wayplatform_connect_tachograph_security_v1_rsa_certificate_proto_depIdxs = nil
}
